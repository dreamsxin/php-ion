Promise, Deferred и Sequence
===

- **[Promise](#promise)**
- **[Deferred](#deferred)**
- **[Sequence](#sequence)**
- **[Цепочки](#Цепочки)**
- **[Аргументы в цепочках](#Аргументы-в-цепочках)**
- **[Корутины](#Корутины)**

Расширение предоставляет удобный способ организации асинхронного кода через _промисы_.
Все методы которые делают что-либо асинхронно возвращают объект-промис или промисоподобные объекты.
Объекты-промисы очень похожи на свои аналоги в других языках программирования (Q, Lie, When, RSVP и тд).
Однако имеют ряд отличий от аналогов так как язык программирования и условия другие.


Основная задача промисов сделать асинхронный код проще.

В документации не будет приводится общие способы использования промисов так как этих статей много в интернете.

В расширении есть несколько видов промисов:

* `ION\Promise` - базовый промис.
* `ION\ResolvablePromise` - промис который может быть выполнен в коде.
* `ION\Deferred` - отложенное действие.
* `ION\Sequence` - 'многоразовый' промис.

# Promise

Базовый промис который хранит набор колбеков когда промис будет выполнен.
Однако в отличии `ION\ResolvablePromise` базовый промис `ION\Promise` не может выполнить себя.
Этот промис имеет очень узкое применение и используется в цепочках действий.

```php
$promise = new ION\Promise($on_done = null, $on_fail = null);
```

`ION\Promise` – это специальный объект, который содержит свое состояние. Вначале `pending` (ожидание),
затем – одно из: `done` (выполнено успешно) или `rejected` (выполнено с ошибкой).
На базовый промис можно навешивать коллбэк двух типов:

- `on_done` – срабатывают, когда промис в состоянии «выполнен успешно».
- `on_fail` – срабатывают, когда промис в состоянии «выполнен с ошибкой».

```php
$promise = new ION\Promise($on_done, $on_fail);
```

Простой пример с ожиданием:
```php
ION::await(12)->then(function () {
 // ...
});
```
Метод `ION::await(12)` создает таймер на 12 секунд (аналогия `sleep(12)`) и возвращает
объект-обещание `ION\Promise` выполнить функцию по истечении 12 секунд. 

# Deferred

Отложенное (deferred) действие или результат. Большинство методов расширения возвращают deferred.
Конструктор deferred, опционально, принимает коллбек отмены.
Коллбек отмены нужен для выполнения какого-то кода отката или отмены состояний при отмене deferred.
Отложенное действие очень похоже на базовый промис, но имеет несколько отличий:

1. Отложенное действие можно отменить методом `cancel($reason)` пока оно не выполнялось:

```php
$deferred = ION::await(10);
// запустили таймер на 10 секунд

// после некотрых лействий нужно отменить таймер
$deferred->cancel("отмена!");
```

При отмене отложенного события все его цепочки получат вместо результата исключение `ION\Promise\CancelException` с причиной отмены.

2. Отложенному действию можно задать временные рамки выполнения через метод `timeout($time)`.
По истечению времени, если отложенное действие ещё не выполнялось, оно будет отменено с исключением `ION\Promise\TimeoutException`.

```php
ION::promise(function () {
   return ION\FS::readFile("/nfs/data.json")->timeout(10);
})
->then(function (string $data_json) {

   // если все пройдет успешно то в коллбек мы получим содержимое файла /nfs/data.json

}, function (\Throwable $error) {

   // произошла ошибка и это может быть ION\Promise\TimeoutException, если не удалось прочитать файл за 10 секунд.

});
```


Отложенное действие можно создать в обычном коде

```php
$deferred = new ION\Deferred(function (\Throwable $reason) {
   // этот коллбек вызовется если $deferred будет отменен
});
```

# Sequence

Последовательности (sequences) — многоразовые промисы. Те промисы которые могут быть вызваны несколько раз.
Простой пример на интервале (setInterval в JavaScript)

```php

ION::interval(10)->then($cb1);
```

Коллбек `$cb1` будет вызываться каждые 10 секунд. Все периодические события в `PHP-ION` возвращают `ION\Sequence` промисы.

Название идет от того что это похоже на создание какой-то последовательности (sequence) колбеков которые можно вызывать множество раз.

Последовательность является callable объектом и может быть создана и вызвана вручную:

```php
$sequence = new Sequence(function ($number) {
   // при запуске последовательности это будет первый коллбек в цепочке
   return $number * 2;
})
$sequence->then(function ($number) {
   echo "Удвоено: $number\b";
});

$sequence(5); // выведет Удвоено: 10
```

Эта возможность последовательностей позволяет их использовать как обычные колбеки с асинхронным кодом.


```php
$sequence = new ION\Sequence(callable $start_cb = null, callable $release_cb = null);
```

Особую роль играет стартовый коллбек `$start_cb` последовательности - колбек, который задается только в конструкторе последовательности.

В отличии от других промисов последовательности могут принимать несколько входных аргументов которые должны быть обработаны в стартовом коллбеке:

```php
$sequence = new ION\Sequence(function (int $amount, int $brust) {
   // ...
});

$sequence(107, 0.2);
```

Обратите внимание что только стартовый коллбек может обрабатывать несколько аргументов.

Если стартовый коллбек пытаются вызвать недостающим количеством аргументов или аргументами не того типа то брошено исключений `InvalidArgumentException` при вызове последовательности.
Если инициирующего коллбек нет, а передано более одного аргумента то также будет брошено исключение `InvalidArgumentException`.

Эта способность удобна для того чтобы последовательности можно было задавать как обычный коллбек

```php
set_error_handler(new ION\Sequence(function ($errno, $errstr, $file, $eline, $context) {
   // ...
}));
```

# Цепочки

Все промисы могут порождать цепочки действий для обработки данных или ошибок от предыдущих промисов (по аналогии с pipe в nix системах)

```php
$promise->then(function ($result) { /* ... */})
```

Цепочки могу быть последовательными:

```php
$promise->then($cb1)->then($cb2) /* ... */ ->then($cbN);
```

Тогда каждый последующий коллбек будет ждать предыдущий.

**Важно:**
Текущая реализация не откладывает результат, пропуская другие колбеки, а передает следующему коллбек сразу,
поэтому, если будут вызваны другие промисы стек вызова может увеличиваться при сквозном прохождении результата через колбеки.

Цепочки также могут быть 'параллельными', тогда у одного промиса будет несколько цепочек действий.

```php
$promise->then($cb1);
$promise->then($cb2);
/* ... */
$promise->then($cbN);
```

В этом случае колбеки будут выполняться "параллельно".
Под "параллельно" понимается как только одна из цепочек начинает асинхронно ожидать какое-либо действие то начинает работать другая цепочка.

# Аргументы в цепочках

Промисы в `PHP-ION` чувствительные к типам аргументов колбеков в цепочке,
если результат одного коллбек не подходит в аргументы другому то такой коллбек будет пропущен и результат будет передан другому. И так по цепочке до конца.

```php

$promise
   ->then(function (int $number) {
       // коллбек запустится если результатом $promise было целое число (int)
       return $number * 2;
   })
   ->then(function (array $numbers) {
       // коллбек запустится если результатом $promise был массив
       // в этом случае можем произвести манипуляции с результатом-массивом
       return array_sum($numbers) * 2;
   })
   ->then(function (int $result) {
       // если $promise вернул число или массив то после прохождений соответвующих коллебеков
       // числовой результат окажется здесь
       echo "Результат удвоения: $result\n";
   });

```

Таким образом можно ветвить цепочки промисов оперируя типами требуемых аргументов.
Если нужно получить любой результат то не указывайте тип аргумента.

Аналогично все работает и с исключениями при ошибках.
Если нужно поймать любое исключение то указывайте тип аргумента `\Throwable` или не указывайте вовсе.

```php
$promise
   ->onFail(function (ION\FSException $error) {
       // ошибка при работе с файловой системой - очень важно и можно обработать индивидуально
       throw $error;
   })
   ->onFail(function (\Throwable $error) {
       // любая ошибка попадет сюда
   });

```

# Корутины

Каждый промис и его производные объекты могут быть корутиной.
То есть промис может быть использован в генераторах для прерывания работы кода пока промис не будет выполнен.
Это позволяет избегать большие цепочки, а программировать в "синхронном стиле".
 
```php

ION::promise(function () {
   // некий код ...
   yield ION::await(12);
   // код который будет выполнен спустя 12 секунд
});

```

Результат промиса будет передан в генератор

```php
ION::promise(function () {
   // прочитаем асинхронно файл /var/log/app.log
  
   $logs = yield ION\FS::readFile("/var/log/app.log");
  
   // $logs - теперь имеет содержимое файла /var/log/app.log
});

```

В случае ошибки промиса генератор выбросит исключение

```php
ION::promise(function () {
   // прочитаем асинхронно не существующий файл
  
   try {
       $logs = yield ION\FS::readFile("/not_exists");
   } catch(ION\FSException $error) {
       // получим ошибку что файла не существует
   }
});

```

Если генератор вернул не промис то это значение будет возвращено сразу

```php

ION::promise(function () {
   $five = yield 5;
   // $five === 5
});

```

Все верно если генератор пробрасывает результат через `yield from` оператор

```php
function read_configs(array $paths) {
   $configs = [];
   foreach($paths as $path) {
       $configs[$path] = yield ION\FS::readFile($path);
   }
   return $configs;
}

ION::promise(function () {
   $configs = yield form read_configs(["/etc/app/config.conf", "/etc/app/conf.d/extras.conf"]);
  
   // $configs - массив который содержит контент файлов /etc/app/config.conf и /etc/app/conf.d/extras.conf
});

```

**Важно:**
Рекомендуется использовать корутины вместо цепочек так как они производительнее и потребляют меньше ресурсов компьютера.

Корутины отлично работают с последовательностями Sequence

```php
ION::promise(function () {
  
   yield ION::interval(12); // отработает единожды и ничем не отличается от ION::await(12)
});
```

# ION::promise()

Универасльный метод `ION::promise()` который всегда возвращает промис на основании аргументов. 
Таким образом если не уверены какие данные получаете можете их пропустить через метод `ION::promise()`.

* Объект `ION\Promise` и его производные. 
```php
ION::promise(FS::readFile("configs/app.cert"))->then('var_dump');

// результатом будет содержимое файла configs/app.cert
```
* Колбек Closure. Завершит промис когда будет выполнен колбек или брошено исключение. Колбек поддерживает корутины. 

    ```php
    ION::promise(function () {
        $result = [];
        $result["cert"] = yield FS::readFile("configs/app.cert");
        $result["pkey"] = yield FS::readFile("configs/app.pkey");
        return $result;
    )->then('var_dump');
    
    // результатом будет 
    array(
        "cert" => "содержание файла configs/app.cert",
        "pkey" => "содержание файла configs/app.pkey"
    )
    ```
    
* Генератор. Переберает генератор выполняя промисы. Результат генератора будет результатом промиса.

    ```php
    function read_certs() {
        $result = [];
        $result["cert"] = yield FS::readFile("configs/app.cert");
        $result["pkey"] = yield FS::readFile("configs/app.pkey");
        return $result;
    )
    ION::promise(read_certs())->then('var_dump');
    // результатом будет 
    array(
        "cert" => "содержание файла configs/app.cert",
        "pkey" => "содержание файла configs/app.pkey"
    )
    ```
    
* Массив. Переберет массив и если значение объект ION\Promise и его производные то дождется их выполнения и заменит результатом

    ```php
    ION::promise([
        "cert" => FS::readFile("configs/app.cert"),
        "pkey" => FS::readFile("configs/app.pkey"),
        "domain" => "example.com"
    ])->then('var_dump');
    
    // результатом будет 
    array(
        "cert" => "содержание файл configs/app.cert",
        "pkey" => "содержание файл configs/app.pkey",
        "domain" => "example.com"
    )
    ```
    
* Другие значения. Вренет завершенный промис, где резальтатом будет переданное значение

    ```php
    ION::promise(5)->then('var_dump');
    
    // результатом будет 5
    ```