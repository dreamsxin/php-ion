[ION]

; Instead of checking the current time every time the event loop is ready 
; to run timeout callbacks, check after each timeout callback. 
; @todo add time functions or replace older
ion.engine.cache_time = On

; If we are using the epoll backend, this flag says that it is safe to use 
; Libevent's internal change-list code to batch up adds and deletes in order 
; to try to do as few syscalls as possible.
; Setting this flag can make your code run faster, but it may trigger a Linux bug:
; it is not safe to use this flag if you have any fds cloned by dup() or its variants. 
; Doing so will produce strange and hard-to-diagnose bugs.
; This flag has no effect if you wind up using a backend other than epoll. 
; @todo do it automaticly
ion.engine.use_epoll_changelist = Off

ion.dns.resolv_conf = /etc/resolv.conf
ion.dns.hosts_file = /etc/hosts

; Sets a threshold for the number of dots which must appear in a name given to res_query(3) (see resolver(3))
; before an initial absolute query will be made. The default for n is 1, meaning that if there are any dots in a name,
; the name will be tried first as an absolute name before any search list elements are appended to it.
;
; ion.dns.ndots       = 1

; Sets the amount of time (in seconds) the resolver will wait for a response from a remote
; name server before retrying the query via a different name server.
;
; ion.dns.timeout     = 5

; How many times do we allow a nameserver to time-out in a row before we assume that it’s down?
;
; ion.dns.max_timeouts = 3

; How many DNS requests do we allow to be pending at once?
; (If we try to do more requests than this, the extras will stall until the earlier ones are answered or time out.)
;
; ion.dns.max_inflight = 64

; Sets the number of times the resolver will send a query to its name servers
; before giving up and returning an error to the calling application.
;
; ion.dns.attempts = 2

; If nonzero, we randomize the case on outgoing DNS requests and make sure that replies
; have the same case as our requests. This so-called "0x20 hack" can help prevent
; some otherwise simple active events against DNS.
;
; ion.dns.randomize_case = 1

; If provided, we bind to the given address whenever we send packets to a nameserver.
;
; ion.dns.bind_to = 0.0.0.0

; When we decide that a nameserver is down, we probe it with exponentially decreasing frequency
; to see if it has come back up. This option configures the first timeout in the series, in seconds.
;
; ion.dns.initial_probe_timeout = 10

; When ION\DNS::getAddrInfo() requests both an IPv4 address and an IPv6 address,
; it does so in separate DNS request packets, since some servers can’t handle both requests in one packet.
; Once it has an answer for one address type, it waits a little while to see if an answer for the other one comes in.
; This option configures how long to wait, in seconds.
;
; ion.dns.getaddrinfo_allow_skew = 3
