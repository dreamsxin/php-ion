Работа с процессами
====

Расширение имеет минимально необходимый набор методов для создания демонов-процессов. 
Это установка пользователя и группы для процесса, настройка приоритета процессов.

# Исполнение внешних программ

Расширение позволяет вызывать подпроцессы асинзронно, то есть разрешить deferred когда процес заершится (успешно или нет)

```php

// получим список файлов которые не под версией
$result = yield ION\Process::exec('git status -s');

// $result instanceof ION\Process\Exec
print $result->stdout; // выведет результат программы git
```

Для более гибкой работы с созданными подпроцессами у метода `ION\Process::exec()` есть набор параметров, который задается массивом.
 
| Параметр | Описание            | Значение                | Значение по умлочанию |
| -------- | ------------------- | ----------------------- | --------------------- |
| `cwd`    | путь в котором будет выполнятся программа | строка, существующий путь до директории | текущая директория (`getcwd()`) |
| `user`   | UID или имя пользователя под которым будет запущена программа | строка или число, существующий пользователь системы | текущий пользователь |
| `group`  | GID или имя группы под которым будет запущена программа | строка или число, существующая группа в системе | текущая группа |
| `pid`    | PID запущенного процесса, задается в переменную по ссылке | ссылка на переменную | |
| `cancel` | Номер или название сигнала, который будет послан при отмене | число или строка | `SIGTERM` |


```php
$result = yield ION\Process::exec('git pull --prune', [
    'cwd' => '/www/app',            // указываем где  выполнять программу
    'pid' => &$this->git_pull_pid   // сохранить PID  процесса программы в свойство 
]);
```

Когда расширение запускает процесс то для процесс объявляется переменная окружения `_ION_EXEC_LINE`, 
которая содержить путь до PHP файла и и строчку где был вызван


```php
$result = yield ION\Process::exec('echo $_ION_EXEC_LINE');

print $result->stdout; // выведет что-то похожее на /www/app/src/CVS/GitDriver.php:562
```

# Дочерние процессы

Для увеличения потоко обработки входящих данных часто использую систему мастер-рабочие. 
Один осонвной процесс, назовем его мастер, порождает другие процессы, их назовем рабочими процессами. 
Рабочие процессы занимаются обработкой данных, в то время как мастер только следит за рабочими 
и запускает/перезапускает рабочих в зависимости от потребности приложения. Для более плотного взаимодействия мастера с 
рабочими процессами используют [IPC](https://en.wikipedia.org/wiki/Inter-process_communication) что бы передавать сообщения.

## Создание дочерних процессов

Обычно такая схема релизуется через парные сокеты и [pcntl_fork](http://docs.php.net/pcntl_fork). 
Схема мастер-рабочий учтена в расширении и реализована в классе `ION\Process\ChildProcess`.


```php

$worker = new ION\Process\ChildProcess();

$worker->whenStarted()->then(function (ION\Process\ChildProcess $worker) {
    // промис разрешится когда процесс запустится и будет иметь свой собственный PID
});

$worker->whenExit()->then(function (ION\Process\ChildProcess $worker) {
    // вызывается когда процесс завершился
});

$worker->start(function (ION\Process\IPC $master_ipc) {
    // $master_ipc соединение с мастер-процессом которое может быть использавнно для передачи сообщений
});

```

## Межпроцессное взаимодействие

Межпроцессное взаимодействие (IPC) предоставляется объектом `ION\Process\IPC`. 
Объект IPC изначально существует у каждого объекта дочернего процесса `ION\Process\ChildProcess`.

```php
$worker = new ION\Process\ChildProcess();

$worker->getIPC()->whenIncoming()->then(function (ION\Process\IPC\Message $message) {
    // Сообщения от дочернего процесса
});

$worker->getIPC()->whenDisconnected()->then(function (ION\Process\ChildProcess $worker) {
    // Разрыв соединения с дочерним процессом. Это может произойти только из-за завершения процесса
});

```

После запуска дочерний процесс получает IPC с мастером

```php

$worker = new ION\Process\ChildProcess();

$worker->start(function (ION\Process\IPC $master_ipc) {
    $master_ipc->whenIncoming()->then(function (ION\Process\IPC\Message $message) {
        // Сообщения от родительского процесса
    });
    
    $master_ipc->whenDisconnected()->then(function (ION\Process\ChildProcess $worker) {
        // Разрыв соединения с родительским процессом. Это может произойти только из-за завершения родительского процесса
    });
});

```

IPC с родителем можно получить в любое время через метод `ION\Process::getParentIPC()`.


## Управление дочерними процессами
