Promise, Deferred и Sequence
===

- **[Promise](#promise)**
- **[Deferred](#deferred)**
- **[Sequence](#sequence)**
- **[Цепочки](#Цепочки)**
- **[Аргументы в цепочках](#Аргументы-в-цепочках)**
- **[Корутины](#Корутины)**

Расширение предоставляет удобный способ организации асинхронного кода через _промисы_.
Все методы которые делают что-либо асинхронно возвращают объект-промис или промисоподобные объекты. 
Объекты-промисы очень похожи на свои аналоги в других языках програмирования (Q, Lie, When, RSVP и тд). 
Однако имеют ряд отличий от аналогов так как язык программирования и условия другие.


Осоновная задача промисов сделать асинхронный код проще. 

В документации не будет приводится общие способы использования просмисов так как этих статей много в интернете.

В расширении есть несколько видов промисов:

* `ION\Promise` - базовый промис.
* `ION\ResolvablePromise` - промис который может быть выполнен в коде.
* `ION\Deferred` - отложенное действие.
* `ION\Sequence` - 'многоразовый' промис.

# Promise

Самый базовый класс промисов. В чистом виде ни один метод `PHP-ION` не возвращает примитивный промис. 
Однако примитивный промис используется в цепочках и возвращается при вызвове `then()`, `onFail()`, `onDone()`.
  
`ION\Promise` – это специальный объект, который содержит своё состояние. Вначале `pending` (ожидание), 
затем – одно из: `done` (выполнено успешно) или `rejected` (выполнено с ошибкой).
На базовый промис можно навешивать коллбэки двух типов:

- `on_done` – срабатывают, когда промис в состоянии «выполнен успешно».
- `on_fail` – срабатывают, когда промис в состоянии «выполнен с ошибкой».
 
```php
$promise = new ION\Promise($on_done, $on_fail);
```

Простой пример с ожиданием:
```php
ION::await(12)->then(function () { 
  // ... 
});
```
Метод `ION::await(12)` создает таймер на 12 секунд (аналогия `sleep(12)`) и возращает 
объект-обещание `ION\Promise` выпонить функцию по истечении 12 секунд.  

# Deferred

Отложенное (deferred) дейстиве или результат. Большинство методов `PHP-ION` возвращают отложенное действие.
Отложенное действие очень похоже на базовый промис, но имеет несколько отличий:

1. Отложенное дейстиве можно отменить методом `cancel($reason)` пока оно не выполнилось:

```php
$deferred = ION::await(10); 
// запустили таймер на 10 секунд

// после некотрых лействий нужно отменить таймер
$deferred->cancel("отмена!");
```

При отмене отложенного события все его цепочки получат вместо результата исключение `ION\Promise\CancelException` с причной отмены.

2. Отложенному действию можно задать временные рамки выполнения через метод `timeout($time)`. 
По истечению времени, если отложенное действие ещё не выполнилось, оно будет отменено с исключением `ION\Promise\TimeoutException`.

```php
ION::promise(function () {
    return ION\FS::readFile("/nfs/data.json")->timeout(10);
})
->then(function (string $data_json) {

    // если все пройдет успешно то в коллбек мы получим содержимое файла /nfs/data.json

}, function (\Throwable $error) {

    // произошла ошибка и это может быть ION\Promise\TimeoutException, если не удалось прочитать файл за 10 секунд.

});
```


Отложенное действие можно создать в обычном коде

```php
$deferred = new ION\Deferred(function (\Throwable $reason) {
    // этот коллбек вызовется если $deferred будет отменен 
});
```

# Sequence

Последовательности (sequences) — многоразовые промисы. Те промисы которые могут быть вызваны несколько раз. 
Простой пример на интервале (setInterval в JavaScript)

```php

ION::interval(10)->then($cb1);
```

Коллбек `$cb1` будет вызываться каждые 10 секунд. Все периодичне события в `PHP-ION` возвращают `ION\Sequence` промисы.

Название идет от того что это похоже на создание какой-то последовательности (sequece) коллбеков которые можно вызывать множесто раз.

Последовательность является callable обектом и может быть создана и вызвана вручную:
 
```php
$sequence = new Sequence(function ($number) {
    // при запуске последовательности это будет первый коллбек в цепочке
    return $number * 2;
})
$sequence->then(function ($number) {
    echo "Удвоено: $number\b";
});

$sequence(5); // напечатет Удвоено: 10
```

Эта возможность последовательностей позволяет их использовать как обычне коллбеки с асинхронным кодом.


```php
$sequence = new ION\Sequence(callable $start_cb = null, callable $release_cb = null);
```

Особую роль играет стартовый коллбек `$start_cb` последовательности - коллбек, который задается только в конструкторе последоательности.

В отличии от других промисов последовательности могут принимать несколько входных аргументов которые доожны быть обработаны в стартовом коллбеке:

```php
$sequence = new ION\Sequence(function (int $amount, int $brust) {
    // ...
});

$sequence(107, 0.2);
```

Обратите внимание что только иниирующий коллбек может обрабатывать несколько аргументов.

Если инициирующий коллбек принимает не то количество аргументов или не того типа то будет 
брошено исключений `InvalidArgumentException` при вызове последовательности.
Если инициирующего коллбека нет, а перенедано более 1го аргумента то так же будет брошено исклбчение `InvalidArgumentException`.

Эта способность удобна для того что бы последовательности можно было задавать как обычный коллбек 

```php
set_error_handler(new ION\Sequence(function ($errno, $errstr, $file, $eline, $context) {
    // ...
}));
```

# Цепочки

Все промисы могут порождать цепочки действий для обработки данных или ошибок от предидущих промисов (по аналогии с pipe в nix системах)

```php
$promise->then(function ($result) { /* ... */})
```

Цепочки могу быть последовательными:
 
```php
$promise->then($cb1)->then($cb2) /* ... */ ->then($cbN);
```

Тогда каждый последующий коллбек будет ждать предидущий.
 
**Важно:**
Текущая реализация не откалдывает результат, пропуская другие коллбеки, а передает следующему коллбеку сразу, 
поэтому стек вызова может уеличиваться при сковзном прохождении результата.

Цепочки так же могут быть 'параллельными', тогда у одного промиса будет несколько цепочек действий.

```php
$promise->then($cb1);
$promise->then($cb2);
/* ... */
$promise->then($cbN);
```

В этом случае коллбеки будут выполнятся "параллельно". 
Под "параллельно" понимается как только одна из цепочек начинает асинхронно ожидать какое-либо действие то начинает работать другая цепочка. 

# Аргументы в цепочках

Промисы в `PHP-ION` чувствительные к типам аргументов колебков в цепочке, 
если результат одного коллбека не подходит в аргументы другому то такой коллбек будет пропущен и результат будет передан другому. И так по цепочке до конца.

```php

$promise
    ->then(function (int $number) {
        // коллбек запустится если результатом $promise было целое число (int)
        return $number * 2;
    })
    ->then(function (array $numbers) {
        // коллбек запустится если результатом $promise был массив
        // в этом случае преобразовываем массив в число и удваиваем его
        return array_sum($numbers) * 2;
    })
    ->then(function (int $result) {
        // если $promise вернул число или массив то после прохождений соответвующих коллебеков
        // числовой результат окажется здесь
        echo "Результат удвоения: $result\n";
    });

```

Таким образом можено ветвить цепочки промисов оперируя типами требуемых аргументов. 
Если нужно получить любой результат то не указывайте тип аргумента.

Аналогично все работате и с исключениями при ошибках. 
Если нужно поймать любое исключение то указывайте тип аргумента `\Throwable` или не указывайте вовсе.

```php
$promise
    ->onFail(function (ION\FSException $error) {
        // ошибка при работе с файловой системой - очень важно и можно обработать индивидуально
        throw $error;
    })
    ->onFail(function (\Throwable $error) {
        // любая ошибка попадет сюда
    });

```

# Корутины

Каждый промис и промисоподобные объекты могут быть корутиной. 
То есть промис может быть использован в генераторах для прерывания работы кода пока промис не будет выполнен. 
Это позволяет избегать большие цепочки, а программировать в "синхронном стиле".
   
```php

ION::promise(function () {
    // некий код ...
    yield ION::await(12);
    // код который будет выполнен спустя 12 секунд
});

```

Результат промиса будет передан в генератор

```php
ION::promise(function () {
    // прочитаем асинхронно файл /var/log/app.log
    
    $logs = yield ION\FS::readFile("/var/log/app.log");
    
    // $logs - теперь имеет содержимое файла /var/log/app.log 
});

```

В случае ошибки промиса генератор выбросит исключение

```php
ION::promise(function () {
    // прочитаем асинхронно не существующий файл
    
    try {
        $logs = yield ION\FS::readFile("/not_exists");
    } catch(ION\FSException $error) {
        // получим ошибку что файла не существует
    }
});

```

Если генератор вернул не промис то это значение бует возвращено сразу

```php

ION::promise(function () {
    $five = yield 5;
    // $five === 5
});

```

Все верно если генератор пробрасывает результат через `yield from` оператор

```php
function read_configs(array $paths) {
    $configs = [];
    foreach($paths as $path) {
        $configs[$path] = yield ION\FS::readFile($path);
    }
    return $configs;
}

ION::promise(function () {
    $configs = yield form read_configs(["/etc/app/config.conf", "/etc/app/conf.d/extras.conf"]);
    
    // $configs - массив который содержит контент файлов /etc/app/config.conf и /etc/app/conf.d/extras.conf
});

```

**Важно:**
Рекомендуется использовать корутины вмето цепочек так как они производителнее и потребляют меньше ресурсов компьютера.

Корутины отлично работают с последовательностями Sequence

```php
ION::promise(function () {
    
    yield ION::interval(12); // отработает единожды и ни чем не отличается от ION::await(12)
});
```

Интервал отработает единожды и ни чем не отличается от `ION::await(12)`. 
Тем не менее корутины не разделяются на классы Promise, Deferred или Sequence.